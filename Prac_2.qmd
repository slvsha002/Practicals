---
title: "prac2"
author: "Shane Silverman"
---

# Question 1: Generate Simulated Data:
```{r}
set.seed(1)
# generate a sequence of numbers from 1 - 100
x <- runif(100, min=0, max=100)
# ei ~ N(0, 0.2)
e <- rnorm(100, mean = 0, sd = 0.2)
# generate y as a noisy sine wave
y <- sin(x / 10) + e 
```

# Question 2: Implement the LOWESS Algorithm
```{r}
customLowess <- function(x, y, f) {
  n <- length(x) # set n to the number of x values
  k <- ceiling(f*n) # number of closest neighbours used for xi
  y_hat <- numeric(n) # create space for smoothed y values
  
  distances_matrix <- abs(outer(x,x, "-")) # calculate the distance between xj and xi
  
  neighbours <- apply(distances_matrix, 1, function(d) order(d)[1:k])
  d_max <- apply(distances_matrix, 1, function(d) max(d[order(d)[1:k]]))
  weights_matrix <- (1-(distances_matrix / d_max)^3)^3
  weights_matrix[distances_matrix > d_max] <- 0
  
  X <- cbind(1, x)
  y_hat <- sapply(1:n, function(i){
    neighbour <- neighbours[, i]
    W <- diag(weights_matrix[i, neighbour])
    X_subset <- X[neighbour, ,drop=FALSE]
    Y_subset <- y[neighbour]
    
    beta <- solve( t(X_subset)%*%W%*%X_subset ) %*% t(X_subset)%*%W%*%Y_subset
    
    return(beta[1]+beta[2]*x[i])
  })
  return(y_hat)
}

y_smooth <- customLowess(x, y, f=0.2)
```

# Question 3: Comparing with R's built in 'lowess()' function
```{r}
builtin_lowess <- lowess(x, y, f=0.2, iter=0)

# Ensure x is sorted before plotting
sorted_indices <- order(x)
x_sorted <- x[sorted_indices]
y_smooth_sorted <- y_smooth[sorted_indices]

# Plot results
plot(x, y, col = "blue", pch = 16, main = "Custom LOWESS Smoothing")
lines(x_sorted, y_smooth_sorted, col = "green", lwd = 7)  # Use sorted x-values
lines(builtin_lowess, col = "red", lwd = 2, lty = 2)
legend("topright", legend = c("Custom LOWESS", "R lowess()"), 
       col = c("green", "red"), lwd = 5, lty = c(1, 2))
```

